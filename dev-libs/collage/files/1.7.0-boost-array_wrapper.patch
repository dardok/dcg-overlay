diff -u -r -N a/co/dataIStreamArchive.h b/co/dataIStreamArchive.h
--- a/co/dataIStreamArchive.h	2017-09-14 12:33:51.536052729 -0400
+++ b/co/dataIStreamArchive.h	2017-09-14 12:35:14.180710643 -0400
@@ -73,7 +73,7 @@
 
     /** @internal use optimized load for arrays. */
     template <typename T>
-    void load_array(boost::serialization::array<T>& a, unsigned int);
+    void load_array(boost::serialization::array_wrapper<T>& a, unsigned int);
 
     /** @internal enable serialization optimization for arrays. */
     struct use_array_optimization
diff -u -r -N a/co/dataIStreamArchive.h.orig b/co/dataIStreamArchive.h.orig
--- a/co/dataIStreamArchive.h.orig	2017-09-14 12:34:10.323202290 -0400
+++ b/co/dataIStreamArchive.h.orig	1969-12-31 19:00:00.000000000 -0500
@@ -1,168 +0,0 @@
-
-/* Copyright (c) 2012, Daniel Nachbaur <danielnachbaur@googlemail.com>
- *               2012, Stefan Eilemann <eile@eyescale.ch>
- *
- * This file is part of Collage <https://github.com/Eyescale/Collage>
- *
- * This library is free software; you can redistribute it and/or modify it under
- * the terms of the GNU Lesser General Public License version 2.1 as published
- * by the Free Software Foundation.
- *
- * This library is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
- * details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this library; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-// Based on portable_iarchive.hpp
-// https://github.com/boost-vault/serialization/eos_portable_archive.zip
-// Copyright Christian Pfligersdorffer, 2007. All rights reserved.
-//
-// Distributed under the Boost Software License, Version 1.0. (See
-// accompanying file LICENSE_1_0.txt or copy at
-// http://www.boost.org/LICENSE_1_0.txt)
-
-#ifndef CO_DATAISTREAMARCHIVE_H
-#define CO_DATAISTREAMARCHIVE_H
-
-#include <co/api.h>
-#include <co/types.h>
-
-#include <boost/version.hpp>
-#pragma warning(push)
-#pragma warning(disable : 4800)
-#include <boost/archive/basic_binary_iarchive.hpp>
-#pragma warning(pop)
-#include <boost/archive/detail/register_archive.hpp>
-#if BOOST_VERSION < 105600
-#include <boost/archive/shared_ptr_helper.hpp>
-#endif
-#include <boost/serialization/is_bitwise_serializable.hpp>
-
-#include <boost/spirit/home/support/detail/endian.hpp>
-#include <boost/spirit/home/support/detail/math/fpclassify.hpp>
-
-#include <boost/type_traits/is_floating_point.hpp>
-#include <boost/type_traits/is_integral.hpp>
-#include <boost/type_traits/is_unsigned.hpp>
-
-#include <boost/utility/enable_if.hpp>
-
-namespace co
-{
-/** A boost.serialization input archive reading from a co::DataIStream. */
-class DataIStreamArchive
-    : public boost::archive::basic_binary_iarchive<DataIStreamArchive>
-#if BOOST_VERSION < 105600
-      ,
-      public boost::archive::detail::shared_ptr_helper
-#endif
-{
-    typedef boost::archive::basic_binary_iarchive<DataIStreamArchive> Super;
-
-public:
-    /** Construct a new deserialization archive. @version 1.0 */
-    CO_API explicit DataIStreamArchive(DataIStream& stream);
-
-    /** @internal archives are expected to support this function */
-    CO_API void load_binary(void* data, std::size_t size);
-
-    /** @internal use optimized load for arrays. */
-    template <typename T>
-    void load_array(boost::serialization::array<T>& a, unsigned int);
-
-    /** @internal enable serialization optimization for arrays. */
-    struct use_array_optimization
-    {
-        template <class T>
-        struct apply : public boost::serialization::is_bitwise_serializable<T>
-        {
-        };
-    };
-
-private:
-    friend class boost::archive::load_access;
-
-    /**
-     * Load boolean.
-     *
-     * Special case loading bool type, preserving compatibility to integer
-     * types - this is somewhat redundant but simply treating bool as integer
-     * type generates lots of warnings.
-     */
-    CO_API void load(bool& b);
-
-    /** Load string types. */
-    template <class C, class T, class A>
-    void load(std::basic_string<C, T, A>& s);
-
-    /**
-     * Load integer types.
-     *
-     * First we load the size information ie. the number of bytes that
-     * hold the actual data. Then we retrieve the data and transform it
-     * to the original value by using load_little_endian.
-     */
-    template <typename T>
-    typename boost::enable_if<boost::is_integral<T> >::type load(T& t);
-
-    /**
-     * Load floating point types.
-     *
-     * We simply rely on fp_traits to set the bit pattern from the (unsigned)
-     * integral type that was stored in the stream. Francois Mauger provided
-     * standardized behaviour for special values like inf and NaN, that need to
-     * be serialized in his application.
-     *
-     * \note by Johan Rade (author of the floating point utilities library):
-     * Be warned that the math::detail::fp_traits<T>::type::get_bits() function
-     * is *not* guaranteed to give you all bits of the floating point number. It
-     * will give you all bits if and only if there is an integer type that has
-     * the same size as the floating point you are copying from. It will not
-     * give you all bits for double if there is no uint64_t. It will not give
-     * you all bits for long double if sizeof(long double) > 8 or there is no
-     * uint64_t.
-     *
-     * The member fp_traits<T>::type::coverage will tell you whether all bits
-     * are copied. This is a typedef for either math::detail::all_bits or
-     * math::detail::not_all_bits.
-     *
-     * If the function does not copy all bits, then it will copy the most
-     * significant bits. So if you serialize and deserialize the way you
-     * describe, and fp_traits<T>::type::coverage is math::detail::not_all_bits,
-     * then your floating point numbers will be truncated. This will introduce
-     * small rounding off errors.
-     */
-    template <typename T>
-    typename boost::enable_if<boost::is_floating_point<T> >::type load(T& t);
-
-#if BOOST_VERSION >= 104400
-    // in boost 1.44 version_type was splitted into library_version_type and
-    // item_version_type, plus a whole bunch of additional strong typedefs
-    CO_API void load(boost::archive::library_version_type& version);
-    CO_API void load(boost::archive::class_id_type& class_id);
-    CO_API void load(boost::serialization::item_version_type& version);
-    CO_API void load(boost::serialization::collection_size_type& version);
-    CO_API void load(boost::archive::object_id_type& object_id);
-    CO_API void load(boost::archive::version_type& version);
-#endif
-
-    CO_API signed char _loadSignedChar();
-
-    DataIStream& _stream;
-};
-}
-
-#include "dataIStreamArchive.ipp" // template implementation
-
-// contains load_override impl for class_name_type
-#include <boost/archive/impl/basic_binary_iarchive.ipp>
-
-BOOST_SERIALIZATION_REGISTER_ARCHIVE(co::DataIStreamArchive)
-BOOST_SERIALIZATION_USE_ARRAY_OPTIMIZATION(co::DataIStreamArchive)
-
-#endif // CO_DATAISTREAMARCHIVE_H
diff -u -r -N a/co/dataIStreamArchive.ipp b/co/dataIStreamArchive.ipp
--- a/co/dataIStreamArchive.ipp	2017-09-14 12:33:51.536052729 -0400
+++ b/co/dataIStreamArchive.ipp	2017-09-14 12:35:27.628817697 -0400
@@ -21,7 +21,7 @@
 namespace co
 {
 template <typename T>
-void DataIStreamArchive::load_array(boost::serialization::array<T>& a,
+void DataIStreamArchive::load_array(boost::serialization::array_wrapper<T>& a,
                                     unsigned int)
 {
     _stream >> Array<T>(a.address(), a.count());
diff -u -r -N a/co/dataIStreamArchive.ipp.orig b/co/dataIStreamArchive.ipp.orig
--- a/co/dataIStreamArchive.ipp.orig	2017-09-14 12:34:10.323202290 -0400
+++ b/co/dataIStreamArchive.ipp.orig	1969-12-31 19:00:00.000000000 -0500
@@ -1,105 +0,0 @@
-
-/* Copyright (c) 2012, Daniel Nachbaur <danielnachbaur@googlemail.com>
- *
- * This library is free software; you can redistribute it and/or modify it under
- * the terms of the GNU Lesser General Public License version 2.1 as published
- * by the Free Software Foundation.
- *
- * This library is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
- * details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this library; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-#include "dataIStream.h"
-#include "dataStreamArchiveException.h"
-
-namespace co
-{
-template <typename T>
-void DataIStreamArchive::load_array(boost::serialization::array<T>& a,
-                                    unsigned int)
-{
-    _stream >> Array<T>(a.address(), a.count());
-}
-
-template <class C, class T, class A>
-void DataIStreamArchive::load(std::basic_string<C, T, A>& s)
-{
-    // implementation only valid for narrow string
-    BOOST_STATIC_ASSERT(sizeof(C) == sizeof(char));
-    _stream >> s;
-}
-
-template <typename T>
-typename boost::enable_if<boost::is_integral<T> >::type
-    DataIStreamArchive::load(T& t)
-{
-#if BOOST_VERSION < 104800
-    namespace bs = boost::detail;
-#else
-    namespace bs = boost::spirit::detail;
-#endif
-
-    // get the number of bytes in the stream
-    if (signed char size = _loadSignedChar())
-    {
-        // check for negative value in unsigned type
-        if (size < 0 && boost::is_unsigned<T>::value)
-            throw DataStreamArchiveException();
-
-        // check that our type T is large enough
-        else if ((unsigned)abs(size) > sizeof(T))
-            throw DataStreamArchiveException(size);
-
-        // reconstruct the value
-        T temp = size < 0 ? -1 : 0;
-        load_binary(&temp, abs(size));
-
-        // load the value from little endian - is is then converted
-        // to the target type T and fits it because size <= sizeof(T)
-        t = bs::load_little_endian<T, sizeof(T)>(&temp);
-    }
-    else
-        // zero optimization
-        t = 0;
-}
-
-template <typename T>
-typename boost::enable_if<boost::is_floating_point<T> >::type
-    DataIStreamArchive::load(T& t)
-{
-    namespace fp = boost::spirit::math;
-    typedef typename fp::detail::fp_traits<T>::type traits;
-
-    // if you end here there are three possibilities:
-    // 1. you're serializing a long double which is not portable
-    // 2. you're serializing a double but have no 64 bit integer
-    // 3. your machine is using an unknown floating point format
-    // after reading the note above you still might decide to
-    // deactivate this static assert and try if it works out.
-    typename traits::bits bits;
-    BOOST_STATIC_ASSERT(sizeof(bits) == sizeof(T));
-    BOOST_STATIC_ASSERT(std::numeric_limits<T>::is_iec559);
-
-    load(bits);
-    traits::set_bits(t, bits);
-
-    // if the no_infnan flag is set we must throw here
-    if (get_flags() & serialization::no_infnan && !fp::isfinite(t))
-        throw DataStreamArchiveException(t);
-
-    // if you end here your floating point type does not support
-    // denormalized numbers. this might be the case even though
-    // your type conforms to IEC 559 (and thus to IEEE 754)
-    if (std::numeric_limits<T>::has_denorm == std::denorm_absent &&
-        fp::fpclassify(t) == (int)FP_SUBNORMAL) // GCC4
-    {
-        throw DataStreamArchiveException(t);
-    }
-}
-}
diff -u -r -N a/co/dataOStreamArchive.h b/co/dataOStreamArchive.h
--- a/co/dataOStreamArchive.h	2017-09-14 12:33:51.536052729 -0400
+++ b/co/dataOStreamArchive.h	2017-09-14 12:35:42.163933406 -0400
@@ -66,7 +66,7 @@
 
     /** @internal use optimized save for arrays. */
     template <typename T>
-    void save_array(const boost::serialization::array<T>& a, unsigned int);
+    void save_array(const boost::serialization::array_wrapper<T>& a, unsigned int);
 
     /** @internal enable serialization optimization for arrays. */
     struct use_array_optimization
diff -u -r -N a/co/dataOStreamArchive.h.orig b/co/dataOStreamArchive.h.orig
--- a/co/dataOStreamArchive.h.orig	2017-09-14 12:34:10.323202290 -0400
+++ b/co/dataOStreamArchive.h.orig	1969-12-31 19:00:00.000000000 -0500
@@ -1,159 +0,0 @@
-
-/* Copyright (c) 2012, Daniel Nachbaur <danielnachbaur@googlemail.com>
- *               2012, Stefan Eilemann <eile@eyescale.ch>
- *
- * This file is part of Collage <https://github.com/Eyescale/Collage>
- *
- * This library is free software; you can redistribute it and/or modify it under
- * the terms of the GNU Lesser General Public License version 2.1 as published
- * by the Free Software Foundation.
- *
- * This library is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
- * details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this library; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-// Based on portable_oarchive.hpp
-// https://github.com/boost-vault/serialization/eos_portable_archive.zip
-// Copyright Christian Pfligersdorffer, 2007. All rights reserved.
-//
-// Distributed under the Boost Software License, Version 1.0. (See
-// accompanying file LICENSE_1_0.txt or copy at
-// http://www.boost.org/LICENSE_1_0.txt)
-
-#ifndef CO_DATAOSTREAMARCHIVE_H
-#define CO_DATAOSTREAMARCHIVE_H
-
-#include <co/api.h>
-#include <co/dataOStream.h>
-#include <co/dataStreamArchiveException.h>
-
-#include <boost/version.hpp>
-
-#include <boost/archive/basic_binary_oarchive.hpp>
-#include <boost/archive/detail/register_archive.hpp>
-#include <boost/serialization/is_bitwise_serializable.hpp>
-#if BOOST_VERSION >= 104400
-#include <boost/serialization/item_version_type.hpp>
-#endif
-
-#include <boost/spirit/home/support/detail/endian.hpp>
-#include <boost/spirit/home/support/detail/math/fpclassify.hpp>
-
-#include <boost/type_traits/is_floating_point.hpp>
-#include <boost/type_traits/is_integral.hpp>
-#include <boost/type_traits/is_signed.hpp>
-
-namespace co
-{
-/** A boost.serialization output archive writing to a co::DataOStream. */
-class DataOStreamArchive
-    : public boost::archive::basic_binary_oarchive<DataOStreamArchive>
-{
-    typedef boost::archive::basic_binary_oarchive<DataOStreamArchive> Super;
-
-public:
-    /** Construct a new serialization archive. @version 1.0 */
-    CO_API explicit DataOStreamArchive(DataOStream& stream);
-
-    /** @internal archives are expected to support this function. */
-    CO_API void save_binary(const void* data, std::size_t size);
-
-    /** @internal use optimized save for arrays. */
-    template <typename T>
-    void save_array(const boost::serialization::array<T>& a, unsigned int);
-
-    /** @internal enable serialization optimization for arrays. */
-    struct use_array_optimization
-    {
-        template <class T>
-        struct apply : public boost::serialization::is_bitwise_serializable<T>
-        {
-        };
-    };
-
-private:
-    friend class boost::archive::save_access;
-
-    /**
-     * Save boolean.
-     *
-     * Saving bool directly, not by const reference because of tracking_type's
-     * operator (bool).
-     */
-    CO_API void save(bool b);
-
-    /** Save string types. */
-    template <class C, class T, class A>
-    void save(const std::basic_string<C, T, A>& s);
-
-    /**
-     * Save integer types.
-     *
-     * First we save the size information ie. the number of bytes that hold the
-     * actual data. We subsequently transform the data using store_little_endian
-     * and store non-zero bytes to the stream.
-     */
-    template <typename T>
-    typename boost::enable_if<boost::is_integral<T> >::type save(const T& t);
-
-    /**
-     * Save floating point types.
-     *
-     * We simply rely on fp_traits to extract the bit pattern into an (unsigned)
-     * integral type and store that into the stream. Francois Mauger provided
-     * standardized behaviour for special values like inf and NaN, that need to
-     * be serialized in his application.
-     *
-     * \note by Johan Rade (author of the floating point utilities library):
-     * Be warned that the math::detail::fp_traits<T>::type::get_bits() function
-     * is *not* guaranteed to give you all bits of the floating point number. It
-     * will give you all bits if and only if there is an integer type that has
-     * the same size as the floating point you are copying from. It will not
-     * give you all bits for double if there is no uint64_t. It will not give
-     * you all bits for long double if sizeof(long double) > 8 or there is no
-     * uint64_t.
-     *
-     * The member fp_traits<T>::type::coverage will tell you whether all bits
-     * are copied. This is a typedef for either math::detail::all_bits or
-     * math::detail::not_all_bits.
-     *
-     * If the function does not copy all bits, then it will copy the most
-     * significant bits. So if you serialize and deserialize the way you
-     * describe, and fp_traits<T>::type::coverage is math::detail::not_all_bits,
-     * then your floating point numbers will be truncated. This will introduce
-     * small rounding off errors.
-     */
-    template <typename T>
-    typename boost::enable_if<boost::is_floating_point<T> >::type save(
-        const T& t);
-
-#if BOOST_VERSION >= 104400
-    // in boost 1.44 version_type was splitted into library_version_type and
-    // item_version_type, plus a whole bunch of additional strong typedefs
-    CO_API void save(const boost::archive::library_version_type& version);
-    CO_API void save(const boost::archive::class_id_type& class_id);
-    CO_API void save(const boost::serialization::item_version_type& class_id);
-    CO_API
-    void save(const boost::serialization::collection_size_type& class_id);
-    CO_API void save(const boost::archive::object_id_type& object_id);
-    CO_API void save(const boost::archive::version_type& version);
-#endif
-
-    CO_API void _saveSignedChar(const signed char& c);
-
-    DataOStream& _stream;
-};
-
-#include "dataOStreamArchive.ipp" // template implementation
-}
-
-BOOST_SERIALIZATION_REGISTER_ARCHIVE(co::DataOStreamArchive)
-BOOST_SERIALIZATION_USE_ARRAY_OPTIMIZATION(co::DataOStreamArchive)
-
-#endif // CO_DATAOSTREAMARCHIVE_H
diff -u -r -N a/co/dataOStreamArchive.ipp b/co/dataOStreamArchive.ipp
--- a/co/dataOStreamArchive.ipp	2017-09-14 12:33:51.536052729 -0400
+++ b/co/dataOStreamArchive.ipp	2017-09-14 12:35:54.213029324 -0400
@@ -16,7 +16,7 @@
  */
 
 template <typename T>
-void DataOStreamArchive::save_array(const boost::serialization::array<T>& a,
+void DataOStreamArchive::save_array(const boost::serialization::array_wrapper<T>& a,
                                     unsigned int)
 {
     _stream << Array<const T>(a.address(), a.count());
diff -u -r -N a/co/dataOStreamArchive.ipp.orig b/co/dataOStreamArchive.ipp.orig
--- a/co/dataOStreamArchive.ipp.orig	2017-09-14 12:34:10.323202290 -0400
+++ b/co/dataOStreamArchive.ipp.orig	1969-12-31 19:00:00.000000000 -0500
@@ -1,115 +0,0 @@
-
-/* Copyright (c) 2012, Daniel Nachbaur <danielnachbaur@googlemail.com>
- *
- * This library is free software; you can redistribute it and/or modify it under
- * the terms of the GNU Lesser General Public License version 2.1 as published
- * by the Free Software Foundation.
- *
- * This library is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
- * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
- * details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this library; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-template <typename T>
-void DataOStreamArchive::save_array(const boost::serialization::array<T>& a,
-                                    unsigned int)
-{
-    _stream << Array<const T>(a.address(), a.count());
-}
-
-template <class C, class T, class A>
-void DataOStreamArchive::save(const std::basic_string<C, T, A>& s)
-{
-    // implementation only valid for narrow string
-    BOOST_STATIC_ASSERT(sizeof(C) == sizeof(char));
-    _stream << s;
-}
-
-template <typename T>
-typename boost::enable_if<boost::is_integral<T> >::type
-    DataOStreamArchive::save(const T& t)
-{
-#if BOOST_VERSION < 104800
-    namespace bs = boost::detail;
-#else
-    namespace bs = boost::spirit::detail;
-#endif
-
-    if (T temp = t)
-    {
-        // examine the number of bytes
-        // needed to represent the number
-        signed char size = 0;
-        do
-        {
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wshift-count-overflow"
-            temp >>= CHAR_BIT;
-#pragma clang diagnostic pop
-            ++size;
-        } while (temp != 0 && temp != (T)-1);
-
-        // encode the sign bit into the size
-        _saveSignedChar(t > 0 ? size : -size);
-        BOOST_ASSERT(t > 0 || boost::is_signed<T>::value);
-
-        // we choose to use little endian because this way we just
-        // save the first size bytes to the stream and skip the rest
-        bs::store_little_endian<T, sizeof(T)>(&temp, t);
-        save_binary(&temp, size);
-    }
-    else
-        // zero optimization
-        _saveSignedChar(0);
-}
-
-template <typename T>
-typename boost::enable_if<boost::is_floating_point<T> >::type
-    DataOStreamArchive::save(const T& t)
-{
-    namespace fp = boost::spirit::math;
-
-    typedef typename fp::detail::fp_traits<T>::type traits;
-
-    // if the no_infnan flag is set we must throw here
-    if (get_flags() & serialization::no_infnan && !fp::isfinite(t))
-        throw DataStreamArchiveException(t);
-
-    // if you end here there are three possibilities:
-    // 1. you're serializing a long double which is not portable
-    // 2. you're serializing a double but have no 64 bit integer
-    // 3. your machine is using an unknown floating point format
-    // after reading the note above you still might decide to
-    // deactivate this static assert and try if it works out.
-    typename traits::bits bits;
-    BOOST_STATIC_ASSERT(sizeof(bits) == sizeof(T));
-    BOOST_STATIC_ASSERT(std::numeric_limits<T>::is_iec559);
-
-    // examine value closely
-    switch (fp::fpclassify(t))
-    {
-    case FP_ZERO:
-        bits = 0;
-        break;
-    case FP_NAN:
-        bits = traits::exponent | traits::mantissa;
-        break;
-    case FP_INFINITE:
-        bits = traits::exponent | (t < 0) * traits::sign;
-        break;
-    case FP_SUBNORMAL:
-        assert(std::numeric_limits<T>::has_denorm);
-    case FP_NORMAL:
-        traits::get_bits(t, bits);
-        break;
-    default:
-        throw DataStreamArchiveException(t);
-    }
-
-    save(bits);
-}
Binary files a/.git/index and b/.git/index differ
diff -u -r -N a/.git/logs/HEAD b/.git/logs/HEAD
--- a/.git/logs/HEAD	2017-09-14 12:33:51.534052713 -0400
+++ b/.git/logs/HEAD	2017-09-14 12:34:28.301345411 -0400
@@ -1 +1 @@
-0000000000000000000000000000000000000000 f320324f091b81c3ec5a26ed16ffc5c0fb49da29 Dardo D Kleiner <dardokleiner@gmail.com> 1505406831 -0400	clone: from git://github.com/Eyescale/Collage.git
+0000000000000000000000000000000000000000 f320324f091b81c3ec5a26ed16ffc5c0fb49da29 Dardo D Kleiner <dardokleiner@gmail.com> 1505406868 -0400	clone: from git://github.com/Eyescale/Collage.git
diff -u -r -N a/.git/logs/refs/remotes/origin/HEAD b/.git/logs/refs/remotes/origin/HEAD
--- a/.git/logs/refs/remotes/origin/HEAD	2017-09-14 12:33:51.534052713 -0400
+++ b/.git/logs/refs/remotes/origin/HEAD	2017-09-14 12:34:28.301345411 -0400
@@ -1 +1 @@
-0000000000000000000000000000000000000000 e2bc13dc2f85535e1f8caeb13f53b62c2bacb734 Dardo D Kleiner <dardokleiner@gmail.com> 1505406831 -0400	clone: from git://github.com/Eyescale/Collage.git
+0000000000000000000000000000000000000000 e2bc13dc2f85535e1f8caeb13f53b62c2bacb734 Dardo D Kleiner <dardokleiner@gmail.com> 1505406868 -0400	clone: from git://github.com/Eyescale/Collage.git
